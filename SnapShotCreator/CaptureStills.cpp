/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
// CaptureStills.cpp
//

#include "include/spdlog/spdlog.h"
#include "platform.h"
#include "Bgr24VideoFrame.h"
#include "Bgra32VideoFrame.h"
#include "DeckLinkInputDevice.h"
#include "DeckLinkAPI.h"
#include "ImageWriter.h"

#include "CaptureStills.h"

void CaptureStills::CreateSnapshot(DeckLinkInputDevice* deckLinkInput, const std::string& captureDirectory, const std::string& filenamePrefix, const std::string& imageFormat,
	std::string& filepath, std::string& err)
{
	HRESULT						result = S_OK;
	bool						captureRunning = true;

	IDeckLinkVideoFrame*		receivedVideoFrame = NULL;
	IDeckLinkVideoConversion*	deckLinkFrameConverter = NULL;
	IDeckLinkVideoFrame*		videoFrame = NULL;

	try
	{
		// Create frame conversion instance
		result = GetDeckLinkVideoConversion(&deckLinkFrameConverter);
		if (result != S_OK)
		{
			throw std::runtime_error("Failed to get DeckLink frame converter");
		}

		bool captureCancelled;
		if (!deckLinkInput->WaitForVideoFrameArrived(&receivedVideoFrame, captureCancelled))
		{
			throw std::runtime_error("Timeout waiting for valid frame");
		}

		else if (captureCancelled)
		{
			throw std::runtime_error("Capture is cancelled");
		}

		else
		{
			filepath = ImageWriter::GetFilepath(captureDirectory, filenamePrefix, imageFormat);
			spdlog::info("Capturing frame to {}", filepath.c_str());

			if (receivedVideoFrame->GetPixelFormat() == bmdFormat8BitBGRA)
			{
				// Frame is already 8-bit BGRA - no conversion required
				spdlog::debug("Frame is already 8-bit BGRA - no conversion required");
				videoFrame = receivedVideoFrame;
				videoFrame->AddRef();
			}
			else
			{
				if (imageFormat == "jpeg")
				{
					// FIXME: Bgr24VideoFrame outputs incorrect images.
					spdlog::debug("Converting to 24-bit BGR video frame");
					videoFrame = new Bgr24VideoFrame(receivedVideoFrame->GetWidth(), receivedVideoFrame->GetHeight(), receivedVideoFrame->GetFlags());
				}
				else
				{
					spdlog::debug("Converting to 32-bit BGRA video frame");
					videoFrame = new Bgra32VideoFrame(receivedVideoFrame->GetWidth(), receivedVideoFrame->GetHeight(), receivedVideoFrame->GetFlags());
				}

				result = deckLinkFrameConverter->ConvertFrame(receivedVideoFrame, videoFrame);
				if (FAILED(result))
				{
					throw std::runtime_error("Frame conversion was unsuccessful");
				}
			}

			result = ImageWriter::WriteVideoFrameToImage(videoFrame, filepath, imageFormat);
			if (FAILED(result))
			{
				throw std::runtime_error("Image encoding to file was unsuccessful");
			}

			videoFrame->Release();

			err = "";
			spdlog::info("Capture completed");
		}
	}
	catch(const std::exception& ex)
	{
		spdlog::dump_backtrace();
		err = ex.what();
		spdlog::error(err.c_str());
	}

	if (receivedVideoFrame != NULL)
	{
		receivedVideoFrame->Release();
		receivedVideoFrame = NULL;
	}

	if (deckLinkFrameConverter != NULL)
	{
		deckLinkFrameConverter->Release();
		deckLinkFrameConverter = NULL;
	}
}

void CaptureStills::DisplayUsage(DeckLinkInputDevice* selectedDeckLinkInput, const std::vector<std::string>& deviceNames,
	const int selectedDeviceIndex, const int selectedDisplayModeIndex, const bool supportsFormatDetection)
{
	HRESULT								result = E_FAIL;
	std::string							selectedDisplayModeName;
	std::vector<IDeckLinkDisplayMode*>	displayModes;

	spdlog::info("Usage: SnapShotCreator.exe -d <device id> -p <port> --log-dir <log directory> [OPTIONS]");

	spdlog::info("    -d <device id>:");
	if (deviceNames.empty())
	{
		spdlog::error("        No DeckLink devices found. Please check that Desktop Video is installed.");
	}
	else
	{
		// Loop through all available devices
		for (size_t i = 0; i < deviceNames.size(); i++)
		{
			spdlog::info(
				"       {}{:2d}:  {}",
				((int)i == selectedDeviceIndex) ? '*' : ' ',
				(int)i,
				deviceNames[i].c_str()
			);
		}
	}

	spdlog::info(
		"    -m <mode id>: ({})", ((selectedDeviceIndex >= 0) && (selectedDeviceIndex < (int)deviceNames.size())) ? deviceNames[selectedDeviceIndex].c_str() : ""
	);

	// Loop through all available display modes on the delected DeckLink device
	if (selectedDeckLinkInput == NULL)
	{
		spdlog::error("        No DeckLink device selected");
	}
	else
	{
		if (supportsFormatDetection)
		{
			spdlog::info("       {}-1:  auto detect format (default)",
				(selectedDisplayModeIndex == -1) ? '*' : ' '
			);
		}

		displayModes = selectedDeckLinkInput->GetDisplayModeList();

		for (size_t i = 0; i < displayModes.size(); i++)
		{
			dlstring_t displayModeName;

			result = displayModes[i]->GetName(&displayModeName);
			if (result == S_OK)
			{
				BMDTimeValue frameRateDuration;
				BMDTimeValue frameRateScale;

				displayModes[i]->GetFrameRate(&frameRateDuration, &frameRateScale);

				spdlog::info(
					"       {}{:2d}:  {:<20} {} x {} {:.2f} FPS",
					((int)i == selectedDisplayModeIndex) ? '*' : ' ',
					(int)i,
					DlToCString(displayModeName),
					displayModes[i]->GetWidth(),
					displayModes[i]->GetHeight(),
					(double)frameRateScale / (double)frameRateDuration
				);

				if ((int)i == selectedDisplayModeIndex)
					selectedDisplayModeName = DlToStdString(displayModeName);

				DeleteString(displayModeName);
			}
		}
	}

	spdlog::info("    -f <pixelformat>:");

	if (selectedDeckLinkInput == NULL)
		spdlog::error("        No DeckLink device selected");

	else if ((selectedDisplayModeIndex < -1) || (selectedDisplayModeIndex >= (int)displayModes.size()))
		spdlog::error("        Invalid display mode selected");

	else if (selectedDisplayModeIndex == -1)
		spdlog::info("        Auto-detect mode selected");

	else
	{
		spdlog::info("({})", selectedDisplayModeName.c_str());

		for (unsigned int i = 0; i < kSupportedPixelFormats.size(); i++)
		{
			// Check whether pixel format is supported for display mode
			dlbool_t displayModeSupported;
			result = selectedDeckLinkInput->GetDeckLinkInput()->DoesSupportVideoMode(bmdVideoConnectionUnspecified,
				displayModes[selectedDisplayModeIndex]->GetDisplayMode(),
				std::get<kPixelFormatValue>(kSupportedPixelFormats[i]),
				bmdNoVideoInputConversion,
				bmdSupportedVideoModeDefault,
				NULL,
				&displayModeSupported);

			if ((result == S_OK) && (displayModeSupported))
			{
				spdlog::info(
					"        {:2d}:  {}{}",
					i,
					std::get<kPixelFormatString>(kSupportedPixelFormats[i]).c_str(),
					(i == 0) ? " (default)" : ""
				);
			}
		}
	}
}
