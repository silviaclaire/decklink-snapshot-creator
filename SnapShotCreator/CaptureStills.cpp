/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
// CaptureStills.cpp
//

#include "platform.h"
#include "Bgr24VideoFrame.h"
#include "Bgra32VideoFrame.h"
#include "DeckLinkInputDevice.h"
#include "DeckLinkAPI.h"
#include "ImageWriter.h"

#include "CaptureStills.h"

HRESULT CaptureStills::GetDeckLinkInputDevice(const int deckLinkIndex, DeckLinkInputDevice* selectedDeckLinkInput,
	std::vector<std::string>& deckLinkDeviceNames, bool& supportsFormatDetection)
{
	int 						idx = 0;
	HRESULT						result = E_FAIL;
	IDeckLink*					deckLink = NULL;
	IDeckLinkIterator*			deckLinkIterator = NULL;

	result = GetDeckLinkIterator(&deckLinkIterator);
	fprintf(stderr, "result:%s", result);

	if (result != S_OK)
	{
		fprintf(stderr, "Unable to get DeckLink iterator\n");
		return result;
	}

	while ((result = deckLinkIterator->Next(&deckLink)) == S_OK)
	{
		dlstring_t deckLinkName;

		result = deckLink->GetDisplayName(&deckLinkName);
		if (result == S_OK)
		{
			deckLinkDeviceNames.push_back(DlToStdString(deckLinkName));
			DeleteString(deckLinkName);
		}

		if (idx++ == deckLinkIndex)
		{
			// Check that selected device supports capture
			IDeckLinkProfileAttributes*	deckLinkAttributes = NULL;
			int64_t						ioSupportAttribute = 0;
			dlbool_t					formatDetectionSupportAttribute;

			result = deckLink->QueryInterface(IID_IDeckLinkProfileAttributes, (void**)&deckLinkAttributes);

			if (result != S_OK)
			{
				fprintf(stderr, "Unable to get IDeckLinkAttributes interface\n");
				break;
			}

			// Check whether device supports cpature
			result = deckLinkAttributes->GetInt(BMDDeckLinkVideoIOSupport, &ioSupportAttribute);

			if ((result != S_OK) || ((ioSupportAttribute & bmdDeviceSupportsCapture) == 0))
			{
				fprintf(stderr, "Selected device does not support capture\n");
			}
			else
			{
				// Check if input mode detection is supported.
				result = deckLinkAttributes->GetFlag(BMDDeckLinkSupportsInputFormatDetection, &formatDetectionSupportAttribute);
				supportsFormatDetection = (result == S_OK) && (formatDetectionSupportAttribute != FALSE);

				selectedDeckLinkInput = new DeckLinkInputDevice(deckLink);
			}

			deckLinkAttributes->Release();
		}

		deckLink->Release();
	}
	deckLinkIterator->Release();
	deckLinkIterator = NULL;

	return result;
}

void CaptureStills::CreateSnapshot(DeckLinkInputDevice* deckLinkInput, const int captureInterval, const int framesToCapture,
	const std::string& captureDirectory, const std::string& filenamePrefix, const std::string& imageFormat)
{
	int							captureFrameCount = 0;
	HRESULT						result = S_OK;
	bool						captureRunning = true;

	IDeckLinkVideoFrame*		receivedVideoFrame = NULL;
	IDeckLinkVideoConversion*	deckLinkFrameConverter = NULL;
	IDeckLinkVideoFrame*		videoFrame = NULL;

	// Create frame conversion instance
	result = GetDeckLinkVideoConversion(&deckLinkFrameConverter);
	if (result != S_OK)
		return;

	while (captureRunning)
	{
		bool captureCancelled;
		if (!deckLinkInput->WaitForVideoFrameArrived(&receivedVideoFrame, captureCancelled))
		{
			fprintf(stderr, "Timeout waiting for valid frame\n");
			captureRunning = false;
		}

		else if (captureCancelled)
			captureRunning = false;

		else if ((++captureFrameCount % captureInterval) == 0)
		{
			std::string outputFileName;
			result = ImageWriter::GetNextFilenameWithPrefix(captureDirectory, filenamePrefix, imageFormat, outputFileName);
			if (result != S_OK)
			{
				fprintf(stderr, "Unable to get filename\n");
				captureRunning = false;
			}
			else
			{
				fprintf(stderr, "Capturing frame #%d to %s\n", captureFrameCount, outputFileName.c_str());

				if (receivedVideoFrame->GetPixelFormat() == bmdFormat8BitBGRA)
				{
					// Frame is already 8-bit BGRA - no conversion required
					videoFrame = receivedVideoFrame;
					videoFrame->AddRef();
				}
				else
				{
					if (imageFormat == "jpeg")
					{
						// FIXME: Bgr24VideoFrame outputs incorrect images.
						videoFrame = new Bgr24VideoFrame(receivedVideoFrame->GetWidth(), receivedVideoFrame->GetHeight(), receivedVideoFrame->GetFlags());
					}
					else
					{
						videoFrame = new Bgra32VideoFrame(receivedVideoFrame->GetWidth(), receivedVideoFrame->GetHeight(), receivedVideoFrame->GetFlags());
					}

					result = deckLinkFrameConverter->ConvertFrame(receivedVideoFrame, videoFrame);
					if (FAILED(result))
					{
						fprintf(stderr, "Frame conversion was unsuccessful\n");
						captureRunning = false;
					}
				}

				result = ImageWriter::WriteVideoFrameToImage(videoFrame, outputFileName, imageFormat);
				if (FAILED(result))
				{
					fprintf(stderr, "Image encoding to file was unsuccessful\n");
					captureRunning = false;
				}

				videoFrame->Release();

				if ((captureFrameCount / captureInterval) >= framesToCapture)
				{
					fprintf(stderr, "Capture completed\n");
					captureRunning = false;
				}
			}
		}

		if (receivedVideoFrame != NULL)
		{
			receivedVideoFrame->Release();
			receivedVideoFrame = NULL;
		}
	}

	if (deckLinkFrameConverter != NULL)
	{
		deckLinkFrameConverter->Release();
		deckLinkFrameConverter = NULL;
	}
}

void CaptureStills::DisplayUsage(DeckLinkInputDevice* selectedDeckLinkInput, const std::vector<std::string>& deviceNames,
	const int selectedDeviceIndex, const int selectedDisplayModeIndex, const bool supportsFormatDetection)
{
	HRESULT								result = E_FAIL;
	std::string							selectedDisplayModeName;
	std::vector<IDeckLinkDisplayMode*>	displayModes;

	fprintf(stderr,
		"Usage: CaptureStills.exe -d <device id> -m <mode id> [OPTIONS]\n"
		"\n"
		"    -d <device id>:\n"
	);

	if (deviceNames.empty())
	{
		fprintf(stderr, "        No DeckLink devices found. Please check that Desktop Video is installed.\n");
	}
	else
	{
		// Loop through all available devices
		for (size_t i = 0; i < deviceNames.size(); i++)
		{
			fprintf(stderr,
				"       %c%2d:  %s\n",
				((int)i == selectedDeviceIndex) ? '*' : ' ',
				(int)i,
				deviceNames[i].c_str()
			);
		}
	}

	fprintf(stderr,
		"    -m <mode id>: (%s)\n", ((selectedDeviceIndex >= 0) && (selectedDeviceIndex < (int)deviceNames.size())) ? deviceNames[selectedDeviceIndex].c_str() : ""
	);

	// Loop through all available display modes on the delected DeckLink device
	if (selectedDeckLinkInput == NULL)
	{
		fprintf(stderr, "        No DeckLink device selected\n");
	}
	else
	{
		if (supportsFormatDetection)
		{
			fprintf(stderr, "       %c-1:  auto detect format\n",
				(selectedDisplayModeIndex == -1) ? '*' : ' '
			);
		}

		displayModes = selectedDeckLinkInput->GetDisplayModeList();

		for (size_t i = 0; i < displayModes.size(); i++)
		{
			dlstring_t displayModeName;

			result = displayModes[i]->GetName(&displayModeName);
			if (result == S_OK)
			{
				BMDTimeValue frameRateDuration;
				BMDTimeValue frameRateScale;

				displayModes[i]->GetFrameRate(&frameRateDuration, &frameRateScale);

				fprintf(stderr,
					"       %c%2d:  %-20s \t %4li x %4li \t %.2f FPS\n",
					((int)i == selectedDisplayModeIndex) ? '*' : ' ',
					(int)i,
					DlToCString(displayModeName),
					displayModes[i]->GetWidth(),
					displayModes[i]->GetHeight(),
					(double)frameRateScale / (double)frameRateDuration
				);

				if ((int)i == selectedDisplayModeIndex)
					selectedDisplayModeName = DlToStdString(displayModeName);

				DeleteString(displayModeName);
			}
		}
	}

	fprintf(stderr, "    -f <pixelformat>: ");

	if (selectedDeckLinkInput == NULL)
		fprintf(stderr, "\n        No DeckLink device selected\n");

	else if ((selectedDisplayModeIndex < -1) || (selectedDisplayModeIndex >= (int)displayModes.size()))
		fprintf(stderr, "\n        Invalid display mode selected\n");

	else if (selectedDisplayModeIndex == -1)
		fprintf(stderr, "\n        Auto-detect mode selected\n");

	else
	{
		fprintf(stderr, "(%s)\n", selectedDisplayModeName.c_str());

		for (unsigned int i = 0; i < kSupportedPixelFormats.size(); i++)
		{
			// Check whether pixel format is supported for display mode
			dlbool_t displayModeSupported;
			result = selectedDeckLinkInput->GetDeckLinkInput()->DoesSupportVideoMode(bmdVideoConnectionUnspecified,
				displayModes[selectedDisplayModeIndex]->GetDisplayMode(),
				std::get<kPixelFormatValue>(kSupportedPixelFormats[i]),
				bmdNoVideoInputConversion,
				bmdSupportedVideoModeDefault,
				NULL,
				&displayModeSupported);

			if ((result == S_OK) && (displayModeSupported))
			{
				fprintf(stderr,
					"        %2d:  %s%s\n",
					i,
					std::get<kPixelFormatString>(kSupportedPixelFormats[i]).c_str(),
					(i == 0) ? " (default)" : ""
				);
			}
		}
	}

	fprintf(stderr,
		"    -n <frames>          Number of frames to capture (default is 1)\n"
		"    -i <interval>        Capture frame interval rate (default is 1 - every frame)\n"
		"    -p <port>            Server port to be exposed for requests (2000 - 65535)\n"
		"Capture image stills to a specified directory. eg:\n"
		"\n"
		"    CaptureStills.exe -d 0 -m 23 -p 8080"
	);
}
