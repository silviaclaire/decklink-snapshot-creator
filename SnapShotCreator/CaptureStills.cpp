/* -LICENSE-START-
** Copyright (c) 2018 Blackmagic Design
**
** Permission is hereby granted, free of charge, to any person or organization
** obtaining a copy of the software and accompanying documentation covered by
** this license (the "Software") to use, reproduce, display, distribute,
** execute, and transmit the Software, and to prepare derivative works of the
** Software, and to permit third-parties to whom the Software is furnished to
** do so, all subject to the following:
**
** The copyright notices in the Software and this entire statement, including
** the above license grant, this restriction and the following disclaimer,
** must be included in all copies of the Software, in whole or in part, and
** all derivative works of the Software, unless such copies or derivative
** works are solely in the form of machine-executable object code generated by
** a source language processor.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
** -LICENSE-END-
*/
// CaptureStills.cpp
//

#include "Logger.h"
#include "platform.h"
#include "Bgr24VideoFrame.h"
#include "Bgra32VideoFrame.h"
#include "DeckLinkInputDevice.h"
#include "DeckLinkAPI.h"
#include "ImageWriter.h"

#include "CaptureStills.h"

void CaptureStills::CreateSnapshot(DeckLinkInputDevice* deckLinkInput, const std::string& captureDirectory, const std::string& filenamePrefix, const std::string& imageFormat,
	std::string& filepath, std::string& err)
{
	HRESULT						result = S_OK;
	bool						captureRunning = true;

	IDeckLinkVideoFrame*		receivedVideoFrame = NULL;
	IDeckLinkVideoConversion*	deckLinkFrameConverter = NULL;
	IDeckLinkVideoFrame*		videoFrame = NULL;

	// Unknown error if not overridden
	err = "Unknown error";

	// Create frame conversion instance
	result = GetDeckLinkVideoConversion(&deckLinkFrameConverter);
	if (result != S_OK)
	{
		err = "Failed to get DeckLink frame converter";
		LOGGER->Log(LOG_ERROR, err.c_str());
		return;
	}

	while (captureRunning)
	{
		bool captureCancelled;
		if (!deckLinkInput->WaitForVideoFrameArrived(&receivedVideoFrame, captureCancelled))
		{
			err = "Timeout waiting for valid frame";
			LOGGER->Log(LOG_ERROR, err.c_str());
			captureRunning = false;
		}

		else if (captureCancelled)
			captureRunning = false;

		else
		{
			filepath = ImageWriter::GetFilepath(captureDirectory, filenamePrefix, imageFormat);
			LOGGER->Log(LOG_INFO, "Capturing frame to %s", filepath.c_str());

			if (receivedVideoFrame->GetPixelFormat() == bmdFormat8BitBGRA)
			{
				// Frame is already 8-bit BGRA - no conversion required
				LOGGER->Log(LOG_DEBUG, "Frame is already 8-bit BGRA - no conversion required");
				videoFrame = receivedVideoFrame;
				videoFrame->AddRef();
			}
			else
			{
				if (imageFormat == "jpeg")
				{
					// FIXME: Bgr24VideoFrame outputs incorrect images.
					LOGGER->Log(LOG_DEBUG, "Converting to 24-bit BGR video frame");
					videoFrame = new Bgr24VideoFrame(receivedVideoFrame->GetWidth(), receivedVideoFrame->GetHeight(), receivedVideoFrame->GetFlags());
				}
				else
				{
					LOGGER->Log(LOG_DEBUG, "Converting to 32-bit BGRA video frame");
					videoFrame = new Bgra32VideoFrame(receivedVideoFrame->GetWidth(), receivedVideoFrame->GetHeight(), receivedVideoFrame->GetFlags());
				}

				result = deckLinkFrameConverter->ConvertFrame(receivedVideoFrame, videoFrame);
				if (FAILED(result))
				{
					err = "Frame conversion was unsuccessful";
					LOGGER->Log(LOG_ERROR, err.c_str());
					captureRunning = false;
				}
			}

			result = ImageWriter::WriteVideoFrameToImage(videoFrame, filepath, imageFormat);
			if (FAILED(result))
			{
				err = "Image encoding to file was unsuccessful";
				LOGGER->Log(LOG_ERROR, err.c_str());
				captureRunning = false;
			}

			videoFrame->Release();

			err = "";
			LOGGER->Log(LOG_INFO, "Capture completed");
			captureRunning = false;
		}

		if (receivedVideoFrame != NULL)
		{
			receivedVideoFrame->Release();
			receivedVideoFrame = NULL;
		}
	}

	if (deckLinkFrameConverter != NULL)
	{
		deckLinkFrameConverter->Release();
		deckLinkFrameConverter = NULL;
	}
}

void CaptureStills::DisplayUsage(DeckLinkInputDevice* selectedDeckLinkInput, const std::vector<std::string>& deviceNames,
	const int selectedDeviceIndex, const int selectedDisplayModeIndex, const bool supportsFormatDetection, const int portno)
{
	HRESULT								result = E_FAIL;
	std::string							selectedDisplayModeName;
	std::vector<IDeckLinkDisplayMode*>	displayModes;

	LOGGER->Log(LOG_INFO, "Usage: CaptureStills.exe -d <device id> -p <port> [OPTIONS]");


	LOGGER->Log(LOG_INFO, "    -d <device id>:");
	if (deviceNames.empty())
	{
		LOGGER->Log(LOG_ERROR, "        No DeckLink devices found. Please check that Desktop Video is installed.");
	}
	else
	{
		// Loop through all available devices
		for (size_t i = 0; i < deviceNames.size(); i++)
		{
			LOGGER->Log(LOG_INFO,
				"       %c%2d:  %s",
				((int)i == selectedDeviceIndex) ? '*' : ' ',
				(int)i,
				deviceNames[i].c_str()
			);
		}
	}

	LOGGER->Log(LOG_INFO, "    -p <port>: (%d)", portno);

	LOGGER->Log(LOG_INFO,
		"    -m <mode id>: (%s)", ((selectedDeviceIndex >= 0) && (selectedDeviceIndex < (int)deviceNames.size())) ? deviceNames[selectedDeviceIndex].c_str() : ""
	);

	// Loop through all available display modes on the delected DeckLink device
	if (selectedDeckLinkInput == NULL)
	{
		LOGGER->Log(LOG_ERROR, "        No DeckLink device selected");
	}
	else
	{
		if (supportsFormatDetection)
		{
			LOGGER->Log(LOG_INFO, "       %c-1:  auto detect format (default)",
				(selectedDisplayModeIndex == -1) ? '*' : ' '
			);
		}

		displayModes = selectedDeckLinkInput->GetDisplayModeList();

		for (size_t i = 0; i < displayModes.size(); i++)
		{
			dlstring_t displayModeName;

			result = displayModes[i]->GetName(&displayModeName);
			if (result == S_OK)
			{
				BMDTimeValue frameRateDuration;
				BMDTimeValue frameRateScale;

				displayModes[i]->GetFrameRate(&frameRateDuration, &frameRateScale);

				LOGGER->Log(LOG_INFO,
					"       %c%2d:  %-20s \t %4li x %4li \t %.2f FPS",
					((int)i == selectedDisplayModeIndex) ? '*' : ' ',
					(int)i,
					DlToCString(displayModeName),
					displayModes[i]->GetWidth(),
					displayModes[i]->GetHeight(),
					(double)frameRateScale / (double)frameRateDuration
				);

				if ((int)i == selectedDisplayModeIndex)
					selectedDisplayModeName = DlToStdString(displayModeName);

				DeleteString(displayModeName);
			}
		}
	}

	LOGGER->Log(LOG_INFO, "    -f <pixelformat>:");

	if (selectedDeckLinkInput == NULL)
		LOGGER->Log(LOG_INFO, "        No DeckLink device selected");

	else if ((selectedDisplayModeIndex < -1) || (selectedDisplayModeIndex >= (int)displayModes.size()))
		LOGGER->Log(LOG_ERROR, "        Invalid display mode selected");

	else if (selectedDisplayModeIndex == -1)
		LOGGER->Log(LOG_INFO, "        Auto-detect mode selected");

	else
	{
		LOGGER->Log(LOG_INFO, "(%s)", selectedDisplayModeName.c_str());

		for (unsigned int i = 0; i < kSupportedPixelFormats.size(); i++)
		{
			// Check whether pixel format is supported for display mode
			dlbool_t displayModeSupported;
			result = selectedDeckLinkInput->GetDeckLinkInput()->DoesSupportVideoMode(bmdVideoConnectionUnspecified,
				displayModes[selectedDisplayModeIndex]->GetDisplayMode(),
				std::get<kPixelFormatValue>(kSupportedPixelFormats[i]),
				bmdNoVideoInputConversion,
				bmdSupportedVideoModeDefault,
				NULL,
				&displayModeSupported);

			if ((result == S_OK) && (displayModeSupported))
			{
				LOGGER->Log(LOG_INFO,
					"        %2d:  %s%s",
					i,
					std::get<kPixelFormatString>(kSupportedPixelFormats[i]).c_str(),
					(i == 0) ? " (default)" : ""
				);
			}
		}
	}
}
